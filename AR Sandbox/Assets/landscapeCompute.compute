// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSContour

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float> heightmap;
RWStructuredBuffer<float4> colors;

static float4 Blue = float4(0, 0, 1, 1);
static float4 Green = float4(0.25, 0.5, 0.25, 1);
static float4 Beige = float4(1, 0.25, 0, 1);
static float4 Red = float4(0.5, 0, 0, 1);

float maxTerrainHeight;
float minTerrainHeight;

float4 GetColor(float height)
{
    if (height <= 0.4)
        return lerp(Blue, Green, height/0.4);
    else if (height <= 0.7)
        return lerp(Green, Beige, (height-0.4)/0.3);
    else if (height <= 1.0)
        return lerp(Beige, Red, (height-0.7)/0.3);
    else
        return Red;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= 500+1 || id.y >= 500+1)
        return;

    int vert = id.x+id.y*(501);
    vertices[vert] = float3(id.x, heightmap[vert], id.y);

    float height = (heightmap[vert]-minTerrainHeight)/(maxTerrainHeight);

    colors[vert] = GetColor(height);
}

int CheckHeight(float height, float limit)
{
    if(height > limit){
        return 1;
    }
    else{
        return 0;
    }
}

int GetState(int a, int b, int c, int d)
{
    return a * 8 + b * 4 + c * 2 + d * 1;
}

void DrawLine(int x1, int y1, int x2, int y2, RWStructuredBuffer<float4> colors)
{
    int dx = x2 - x1;
    int dy = y2 - y1;
    int steps = max(abs(dx), abs(dy));
    if (steps == 0)
        return;
    int y = 0;
    int x = 0;
    for (int i = 0; i <= steps; i++)
    {
        colors[x1 + x + (y1 + y) * 501] = float4(0, 0, 0, 1);
        x += dx/steps;
        y += dy/steps;
    }
}

void DrawContour(float limit, RWStructuredBuffer<float3> vertices, float maxTerrainHeight, float minTerrainHeight, RWStructuredBuffer<float4> colors, int idx, int idy)
{
    int state;
    int2 a = int2(idx * 4 + 2, idy * 4);
    int2 b = int2(idx * 4 + 4, idy * 4 + 2);
    int2 c = int2(idx * 4 + 2, idy * 4 + 4);
    int2 d = int2(idx*4, idy*4+2);
    state = GetState(CheckHeight((vertices[idx * 4 + idy * 4 * 501].y - minTerrainHeight) / maxTerrainHeight, limit), 
    CheckHeight((vertices[idx * 4 + 4 + idy * 4 *501].y - minTerrainHeight) /maxTerrainHeight, limit), 
    CheckHeight((vertices[idx  *4 + 4 + (idy * 4 + 4) * 501].y - minTerrainHeight) /maxTerrainHeight, limit), 
    CheckHeight((vertices[idx * 4 + (idy * 4 + 4) *501].y - minTerrainHeight) /maxTerrainHeight, limit));
    [branch] switch(state)
    {
        case 1:
            DrawLine(c.x, c.y, d.x, d.y, colors);
            break;
        case 2:
            DrawLine(b.x, b.y, c.x, c.y, colors);
            break;
        case 3:
            DrawLine(b.x, b.y, d.x, d.y, colors);
            break;
        case 4:
            DrawLine(a.x, a.y, b.x, b.y, colors);
            break;
        case 5:
            DrawLine(a.x, a.y, d.x, d.y, colors);
            DrawLine(b.x, b.y, c.x, c.y, colors);
            break;
        case 6:
            DrawLine(a.x, a.y, c.x, c.y, colors);
            break;
        case 7:
            DrawLine(a.x, a.y, d.x, d.y, colors);
            break;
        case 8:
            DrawLine(a.x, a.y, d.x, d.y, colors);
            break;
        case 9:
            DrawLine(a.x, a.y, c.x, c.y, colors);
            break;
        case 10:
            DrawLine(a.x, a.y, b.x, b.y, colors);
            DrawLine(c.x, c.y, d.x, d.y, colors);
            break;
        case 11:
            DrawLine(a.x, a.y, b.x, b.y, colors);
            break;
        case 12:
            DrawLine(b.x, b.y, d.x, d.y, colors);
            break;
        case 13:
            DrawLine(b.x, b.y, c.x, c.y, colors);
            break;
        case 14:
            DrawLine(d.x, d.y, c.x, c.y, colors);
            break;
    }
}

[numthreads(9,9,1)]
void CSContour (uint3 id : SV_DispatchThreadID)
{
    if (id.x == 125 || id.y == 125)
        return;

    for(int i = 0; i < 21; i++)
    {
        DrawContour((float)i/20.0, vertices, maxTerrainHeight, minTerrainHeight, colors, id.x, id.y);
    }

}









