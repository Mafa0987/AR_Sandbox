#pragma kernel FindVelocity
#pragma kernel UpdateHeights

float c;
float xSize;
float zSize;
float dt;
float vd;
float pd;
float a;

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float> velocity;
RWStructuredBuffer<float> hSums;
RWStructuredBuffer<float4> fluxMap; // x = top, y = bottom, z = left, w = right
RWStructuredBuffer<float> depthMap;
RWStructuredBuffer<float> heightMap;

[numthreads(8,8,1)]
void FindVelocity (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= xSize+1 || id.y >= zSize+1)
        return;

    int vert = id.x + id.y * (xSize + 1);
    float current = vertices[vert].y;
    float4 flux = fluxMap[vert];
    float depth = depthMap[vert];

    float top = id.y < zSize ? vertices[vert + xSize + 1].y : current;
    float bottom = id.y > 0 ? vertices[vert - xSize - 1].y : current;
    float left = id.x > 0 ? vertices[vert - 1].y : current;
    float right = id.x < xSize ? vertices[vert + 1].y : current;

    float dtop = current - top;
    float dbottom = current - bottom;
    float dleft = current - left;
    float dright = current - right;

    flux.x = max(0, flux.x + dtop * a * dt * c);
    flux.y = max(0, flux.y + dbottom * a * dt * c);
    flux.z = max(0, flux.z + dleft * a * dt * c);
    flux.w = max(0, flux.w + dright * a * dt * c);

    float k = min(1, depth * a / ((flux.x + flux.y + flux.z + flux.w)*dt));

    flux.x *= k;
    flux.y *= k;
    flux.z *= k;
    flux.w *= k;

    fluxMap[vert] = flux;
}

[numthreads(8,8,1)]
void UpdateHeights (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= xSize+1 || id.y >= zSize+1)
        return;

    int vert = id.x + id.y * (xSize + 1);
    float4 flux = fluxMap[vert];
    float outflux = flux.x + flux.y + flux.z + flux.w;
    float influxtop = fluxMap[vert + xSize + 1].y;
    float influxbottom = fluxMap[vert - xSize - 1].x;
    float influxleft = fluxMap[vert - 1].w;
    float influxright = fluxMap[vert + 1].z;
    float influx = influxtop + influxbottom + influxleft + influxright;
    float deltavolume = (influx - outflux) * dt;

    depthMap[vert] += deltavolume / a;
    vertices[vert].y = depthMap[vert] + heightMap[vert];
}
