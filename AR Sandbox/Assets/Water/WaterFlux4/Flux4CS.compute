#pragma kernel FindVelocity
#pragma kernel UpdateHeights

float c;
float xSize;
float zSize;
float dt;
float vd;
float pd;
float a;

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float> velocity;
RWStructuredBuffer<float> hSums;
RWStructuredBuffer<float4> fluxMap; // x = top, y = bottom, z = left, w = right
RWStructuredBuffer<float> depthMap;
RWStructuredBuffer<float> heightMap;

[numthreads(8,8,1)]
void FindVelocity (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= xSize || id.y >= zSize)
        return;

    int vert = id.x + id.y * xSize;
    float4 flux = fluxMap[vert];
    float depth = depthMap[vert];
    float current = depth + heightMap[vert] - 0.1;

    float top = id.y < (zSize - 1) ? (depthMap[vert + xSize] + heightMap[vert + xSize] - 0.1) : current;
    float bottom = id.y > 0 ? (depthMap[vert - xSize] + heightMap[vert - xSize] - 0.1) : current;
    float left = id.x > 0 ? (depthMap[vert - 1] + heightMap[vert - 1] - 0.1) : current;
    float right = id.x < (xSize - 1) ? (depthMap[vert + 1] + heightMap[vert + 1] - 0.1) : current;

    float dtop = current - top;
    float dbottom = current - bottom;
    float dleft = current - left;
    float dright = current - right;

    flux.x = max(0, flux.x + dtop * a * dt * c);
    flux.y = max(0, flux.y + dbottom * a * dt * c);
    flux.z = max(0, flux.z + dleft * a * dt * c);
    flux.w = max(0, flux.w + dright * a * dt * c);

    float k = min(1, depth * a / ((flux.x + flux.y + flux.z + flux.w)*dt));

    flux.x *= k;
    flux.y *= k;
    flux.z *= k;
    flux.w *= k;

    if (id.x == 0) flux.z = 0;
    if (id.y == 0) flux.y = 0;
    if (id.x == xSize-1) flux.w = 0;
    if (id.y == zSize-1) flux.x = 0;

    fluxMap[vert] = max(0, flux);
}

[numthreads(8,8,1)]
void UpdateHeights (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= xSize || id.y >= zSize)
        return;

    int vert = id.x + id.y * xSize;
    float4 flux = fluxMap[vert];
    float outflux = flux.x + flux.y + flux.z + flux.w;

    float influxtop = id.y < (zSize-1) ? fluxMap[vert + xSize].y : 0;
    float influxbottom = id.y > 0 ? fluxMap[vert - xSize].x : 0;
    float influxleft = id.x > 0 ? fluxMap[vert - 1].w : 0;
    float influxright = id.x < (xSize-1) ? fluxMap[vert + 1].z: 0;
    
    float influx = influxtop + influxbottom + influxleft + influxright;

    float deltavolume = influx - outflux;

    depthMap[vert] += dt * deltavolume / a;
    vertices[vert].y = depthMap[vert] + heightMap[vert] - 0.1;
}
