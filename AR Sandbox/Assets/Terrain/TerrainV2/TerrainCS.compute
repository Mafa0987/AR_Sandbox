// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSContour

RWStructuredBuffer<float3> vertices;
StructuredBuffer<float> heightmap;
RWTexture2D<float4> colors;

static float4 Blue = float4(0, 0, 1, 1);
static float4 Green = float4(0.25, 0.5, 0.25, 1);
static float4 Beige = float4(1, 0.25, 0, 1);
static float4 Red = float4(0.5, 0, 0, 1);

float maxTerrainHeight;
float minTerrainHeight;

int numVerticesX;
int numVerticesZ;

float4 GetColor(float height)
{
    if (height <= 0.4)
        return lerp(Blue, Green, height/0.4);
    else if (height <= 0.7)
        return lerp(Green, Beige, (height-0.4)/0.3);
    else if (height <= 1.0)
        return lerp(Beige, Red, (height-0.7)/0.3);
    else
        return Red;
}

void ColorSquare(uint2 idxy, int size, float4 color)
{
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
            colors[uint2(idxy.x + i, idxy.y + j)] = color;
    }
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numVerticesX || id.y >= numVerticesZ)
        return;

    int vert = id.x+id.y*(numVerticesX);
    vertices[vert] = float3(id.x, heightmap[vert], id.y);

    float height = (heightmap[vert]-minTerrainHeight)/(maxTerrainHeight);

    //colors[id.xy] = GetColor(height);
    ColorSquare(id.xy*4, 4, GetColor(height));
}

int CheckHeight(float height, float limit)
{
    if(height > limit){
        return 1;
    }
    else{
        return 0;
    }
}

int GetState(int a, int b, int c, int d)
{
    return a * 8 + b * 4 + c * 2 + d * 1;
}

void DrawPixel(int x, int y, RWTexture2D<float4> colors)
{
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 2; j++)
        {
            int x_c = x + j;
            int y_c = y + i;
            if (x_c >= 0 && x_c < 2004 && y_c >= 0 && y_c < 2004)
            {
                colors[uint2(x_c, y_c)] = float4(0, 0, 0, 1);
            }
        }
    }
}

void DrawLine(int x1, int y1, int x2, int y2, RWTexture2D<float4> colors)
{
    int x_diff = x2 - x1;
    int y_diff = y2 - y1;
    int steps = max(abs(x_diff), abs(y_diff));
    if (steps == 0)
        return;
    float xstep = x_diff/steps;
    float ystep = y_diff/steps;
    float x = x1;
    float y = y1;
    for (int i = 0; i <= steps; i++)
    {
        //colors[uint2(round(x), round(y))] = float4(0, 0, 0, 1);
        DrawPixel(round(x), round(y), colors);
        x += xstep;
        y += ystep;
    }
}

// void DrawLine(int x1, int y1, int x2, int y2, RWTexture2D<float4> colors)
// {
//     int dx = x2 - x1;
//     int dy = y2 - y1;
//     int steps = max(abs(dx), abs(dy));
//     if (steps == 0)
//         return;
//     int y = 0;
//     int x = 0;
//     for (int i = 0; i <= steps; i++)
//     {
// //      colors[uint2(x1 + x, y1 + y)] = float4(0, 0, 0, 1);
//         DrawPixel(x1 + x, y1 + y, colors);
//         x += dx/steps;
//         y += dy/steps;
//     }
// }

void DrawContour(float limit, RWStructuredBuffer<float3> vertices, float maxTerrainHeight, float minTerrainHeight, RWTexture2D<float4> colors, int idx, int idy)
{
    int state;
    int hrez = 4;
    int crez = 16;

    float a_val = (vertices[idx * hrez + idy * hrez * numVerticesX].y - minTerrainHeight) / maxTerrainHeight;
    float b_val = (vertices[idx * hrez + hrez + idy * hrez * numVerticesX].y - minTerrainHeight) / maxTerrainHeight;
    float c_val = (vertices[idx * hrez + hrez + (idy * hrez + hrez) * numVerticesX].y - minTerrainHeight) / maxTerrainHeight;
    float d_val = (vertices[idx * hrez + (idy * hrez + hrez) * numVerticesX].y - minTerrainHeight) / maxTerrainHeight;

    int2 a = int2(idx * crez + crez / 2, idy * crez);
    int2 b = int2(idx * crez + crez, idy * crez + crez / 2);
    int2 c = int2(idx * crez + crez / 2, idy * crez + crez);
    int2 d = int2(idx * crez, idy * crez + crez / 2);

    state = GetState(CheckHeight(a_val, limit), 
    CheckHeight(b_val, limit), 
    CheckHeight(c_val, limit), 
    CheckHeight(d_val, limit));
    [branch] switch(state)
    {
        case 1:
            DrawLine(c.x, c.y, d.x, d.y, colors);
            break;
        case 2:
            DrawLine(b.x, b.y, c.x, c.y, colors);
            break;
        case 3:
            DrawLine(b.x, b.y, d.x, d.y, colors);
            break;
        case 4:
            DrawLine(a.x, a.y, b.x, b.y, colors);
            break;
        case 5:
            DrawLine(a.x, a.y, d.x, d.y, colors);
            DrawLine(b.x, b.y, c.x, c.y, colors);
            break;
        case 6:
            DrawLine(a.x, a.y, c.x, c.y, colors);
            break;
        case 7:
            DrawLine(a.x, a.y, d.x, d.y, colors);
            break;
        case 8:
            DrawLine(a.x, a.y, d.x, d.y, colors);
            break;
        case 9:
            DrawLine(a.x, a.y, c.x, c.y, colors);
            break;
        case 10:
            DrawLine(a.x, a.y, b.x, b.y, colors);
            DrawLine(c.x, c.y, d.x, d.y, colors);
            break;
        case 11:
            DrawLine(a.x, a.y, b.x, b.y, colors);
            break;
        case 12:
            DrawLine(b.x, b.y, d.x, d.y, colors);
            break;
        case 13:
            DrawLine(b.x, b.y, c.x, c.y, colors);
            break;
        case 14:
            DrawLine(d.x, d.y, c.x, c.y, colors);
            break;
    }
}

[numthreads(9,9,1)]
void CSContour (uint3 id : SV_DispatchThreadID)
{
    if (id.x == 125 || id.y == 125)
        return;

    for(int i = 0; i < 21; i++)
    {
        DrawContour((float)i/20.0, vertices, maxTerrainHeight, minTerrainHeight, colors, id.x, id.y);
    }

}









