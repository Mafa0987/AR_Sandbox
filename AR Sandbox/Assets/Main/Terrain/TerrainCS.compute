// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSContour
#pragma kernel ShortToInt
#pragma kernel HMProcessing

#define norm(height) ((height-minTerrainHeight)/(maxTerrainHeight-minTerrainHeight))

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float> heightmap;
RWTexture2D<float4> colors;

//test
RWStructuredBuffer<uint> old;
RWStructuredBuffer<uint> ny;
RWStructuredBuffer<uint> average;
int N;
int num_arrays;
//test

static float4 Blue = float4(0, 0, 1, 1);
static float4 Green = float4(0.25, 0.5, 0.25, 1);
static float4 Beige = float4(1, 0.25, 0, 1);
static float4 Red = float4(0.5, 0, 0, 1);
static float4 White = float4(1, 1, 1, 1);

float maxTerrainHeight;
float minTerrainHeight;

int xSize;
int zSize;
int originalWidth;
int originalHeight;
int xCut;
int zCut;

float4 GetColor(float height)
{
    if (height <= 0.25)
        return lerp(Blue, Green, height/0.25);
    else if (height <= 0.5)
        return lerp(Green, Beige, (height-0.25)/0.25);
    else if (height <= 0.75)
        return lerp(Beige, Red, (height-0.5)/0.25);
    else if (height <= 1.0)
        return lerp(Red, White, (height-0.75)/0.25);
    else
        return White;
}

void ColorSquare(uint2 idxy, int size, float4 color)
{
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
            colors[uint2(idxy.x + i, idxy.y + j)] = color;
    }
}

[numthreads(64,1,1)]
void ShortToInt (uint3 id : SV_DispatchThreadID)
{
    uint num = old[id.x];
    uint first = num & 0x0000FFFF;
    uint sec = (num & 0xFFFF0000) >> 16;
    ny[id.x*2] = first;
    ny[id.x*2+1] = sec;
    
    //Noise reduction
    int i_step = id.x * 2;
    for (int j = num_arrays - 1; j >= 0; j--)
    {
        if (j == 0)
        {
            average[i_step] = first;
            average[i_step + 1] = sec;
        }
        else
        {
            average[i_step + N * j] = average[i_step + N * (j - 1)];
            average[i_step + N * j + 1] = average[i_step + N * (j - 1) + 1];
        }
    }
}

[numthreads(8,8,1)]
void HMProcessing (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= xSize || id.y >= zSize)
        return;
    int originalIndex = (id.x + xCut) + (id.y + zCut) * originalWidth;
    int resizedIndex = id.x + id.y * xSize;

    //average noise reduction
    uint sum = 0;
    for (int i = 0; i < num_arrays; i++)
    {
        sum += average[originalIndex + i * N];
    }
    uint height = sum / num_arrays;
    //test

    //uint height = ny[originalIndex];
    heightmap[resizedIndex] = (2000.0 - (float)height)/10.0;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= xSize || id.y >= zSize)
        return;

    int vert = id.x+id.y*(xSize);
    float height = heightmap[vert];
    vertices[vert] = float3(id.x, height, id.y);

    float height_norm = norm(height);

    //colors[id.xy] = GetColor(height);
    ColorSquare(id.xy*4, 4, GetColor(height_norm));
}

int CheckHeight(float height, float limit)
{
    if(height > limit){
        return 1;
    }
    else{
        return 0;
    }
}

int GetState(int a, int b, int c, int d)
{
    return a * 8 + b * 4 + c * 2 + d * 1;
}

void DrawPixel(int x, int y, RWTexture2D<float4> colors)
{
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 2; j++)
        {
            int x_c = x + j;
            int y_c = y + i;
            if (x_c >= 0 && x_c < xSize*4 && y_c >= 0 && y_c < zSize*4)
            {
                colors[uint2(x_c, y_c)] = float4(0, 0, 0, 1);
            }
        }
    }
}

void DrawLine(float x1, float y1, float x2, float y2, RWTexture2D<float4> colors)
{
    x1 = round(x1);
    y1 = round(y1);
    x2 = round(x2);
    y2 = round(y2);
    int x_diff = x2 - x1;
    int y_diff = y2 - y1;
    int steps = max(abs(x_diff), abs(y_diff));
    if (steps == 0)
        return;
    float xstep = (float)x_diff / (float)steps;
    float ystep = (float)y_diff/ (float)steps;
    float x = (float)x1;
    float y = (float)y1;
    for (int i = 0; i <= steps; i++)
    {
        //colors[uint2(round(x), round(y))] = float4(0, 0, 0, 1);
        DrawPixel(round(x), round(y), colors);
        x += xstep;
        y += ystep;
    }
}

void DrawContour(float limit, RWStructuredBuffer<float3> vertices, float maxTerrainHeight, float minTerrainHeight, RWTexture2D<float4> colors, int idx, int idy)
{
    int state;
    int hrez = 4;
    int crez = 16;

    float a_val = norm(vertices[idx * hrez + idy * hrez * xSize].y);
    float b_val = norm(vertices[idx * hrez + hrez + idy * hrez * xSize].y);
    float c_val = norm(vertices[idx * hrez + hrez + (idy * hrez + hrez) * xSize].y);
    float d_val = norm(vertices[idx * hrez + (idy * hrez + hrez) * xSize].y);

    float amt = (limit - a_val) / (b_val - a_val);
    float2 a = float2(lerp(idx*crez, idx*crez+crez, amt), idy * crez);
    amt = (limit - b_val) / (c_val - b_val);
    float2 b = float2(idx * crez + crez, lerp(idy*crez, idy*crez+crez, amt));
    amt = (limit - d_val) / (c_val - d_val);
    float2 c = float2(lerp(idx*crez, idx*crez+crez, amt), idy * crez + crez);
    amt = (limit - a_val) / (d_val - a_val);
    float2 d = float2(idx * crez, lerp(idy*crez, idy*crez+crez, amt));

    state = GetState(CheckHeight(a_val, limit), 
    CheckHeight(b_val, limit), 
    CheckHeight(c_val, limit), 
    CheckHeight(d_val, limit));
    [branch] switch(state)
    {
        case 1:
            DrawLine(c.x, c.y, d.x, d.y, colors);
            break;
        case 2:
            DrawLine(b.x, b.y, c.x, c.y, colors);
            break;
        case 3:
            DrawLine(b.x, b.y, d.x, d.y, colors);
            break;
        case 4:
            DrawLine(a.x, a.y, b.x, b.y, colors);
            break;
        case 5:
            DrawLine(a.x, a.y, d.x, d.y, colors);
            DrawLine(b.x, b.y, c.x, c.y, colors);
            break;
        case 6:
            DrawLine(a.x, a.y, c.x, c.y, colors);
            break;
        case 7:
            DrawLine(a.x, a.y, d.x, d.y, colors);
            break;
        case 8:
            DrawLine(a.x, a.y, d.x, d.y, colors);
            break;
        case 9:
            DrawLine(a.x, a.y, c.x, c.y, colors);
            break;
        case 10:
            DrawLine(a.x, a.y, b.x, b.y, colors);
            DrawLine(c.x, c.y, d.x, d.y, colors);
            break;
        case 11:
            DrawLine(a.x, a.y, b.x, b.y, colors);
            break;
        case 12:
            DrawLine(b.x, b.y, d.x, d.y, colors);
            break;
        case 13:
            DrawLine(b.x, b.y, c.x, c.y, colors);
            break;
        case 14:
            DrawLine(d.x, d.y, c.x, c.y, colors);
            break;
    }
}

[numthreads(8,7,1)]
void CSContour (uint3 id : SV_DispatchThreadID)
{
    if (id.x > floor((xSize-1)/4-1) || id.y > floor(zSize-1)/4-1)
        return;

    for(int i = 0; i < 21; i++)
    {
        DrawContour((float)i/20.0, vertices, maxTerrainHeight, minTerrainHeight, colors, id.x, id.y);
    }
}









