// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ShortToInt
#pragma kernel ColorMapping
#pragma kernel Bilinear
#pragma kernel makeTexture

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<uint> depthDataShort;
RWStructuredBuffer<uint> depthData;
RWStructuredBuffer<float> input;
RWStructuredBuffer<float> output;
float ratioX;
float ratioY;
int inputDimX;
int inputDimY;
int threadsize;
int xCutL;
int zCutB;
int handX;
int handY;
int modelRes;

RWTexture2D<float4> outputTexture;

static float3 colorsArray[] = {float3(1, 0, 0), float3(1, 0.5, 0), float3(1, 1, 0), float3(0, 1, 0), float3(0, 0, 1)};
//static float3 colorsArray[] = {float3(255, 0, 0), float3(255, 127.5, 0), float3(255, 255, 0), float3(0, 255, 0), float3(0, 0, 255)};

float3 GetColor(float height)
{
    if (height == 0)
        return float3(0, 0, 0);
    for (int i = 0; i < 4; i++)
    {
        float lowerBound = i / 4.0;
        float upperBound = lowerBound + 1.0 / 4.0;
        float step = upperBound - lowerBound;
        if (height <= upperBound)
            return lerp(colorsArray[i], colorsArray[i+1], (height-lowerBound)/step);
    }
    return float3(0, 0, 1);
}

[numthreads(64,1,1)]
void ShortToInt (uint3 id : SV_DispatchThreadID)
{
    uint num = depthDataShort[id.x];
    uint first = num & 0x0000FFFF;
    uint sec = (num & 0xFFFF0000) >> 16;
    depthData[id.x*2] = first;
    depthData[id.x*2+1] = sec;
}

// Color mapping
[numthreads(8,8,1)]
void ColorMapping (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= inputDimX || id.y >= inputDimY)
        return;
    float depth = clamp(depthData[id.x + xCutL + (id.y + zCutB)*512] / 4500.0, 0, 1);
    input[id.x*3 + (inputDimY-1-id.y)*3*inputDimX] = GetColor(depth).x*255.0;
    input[id.x*3 + (inputDimY-1-id.y)*3*inputDimX + 1] = GetColor(depth).y*255.0;
    input[id.x*3 + (inputDimY-1-id.y)*3*inputDimX + 2] = GetColor(depth).z*255.0;
}

// Bilinear Interpolation
[numthreads(8,8,1)]
void Bilinear (uint3 id : SV_DispatchThreadID)
{
    int index = id.x * 3 + id.y * 3 * 256;
    float x = id.x * ratioX;
    float y = id.y * ratioY;
    int x1 = (int)floor(x);
    int y1 = (int)floor(y);
    int x2 = min(x1 + 1, inputDimX - 1);
    int y2 = min(y1 + 1, inputDimY - 1);
    float4 c00;
    c00.r = input[x1*3 + y1*3*inputDimX];
    c00.g = input[x1*3 + y1*3*inputDimX + 1];
    c00.b = input[x1*3 + y1*3*inputDimX + 2];
    float4 c10;
    c10.r = input[x2*3 + y1*3*inputDimX];
    c10.g = input[x2*3 + y1*3*inputDimX + 1];
    c10.b = input[x2*3 + y1*3*inputDimX + 2];
    float4 c01;
    c01.r = input[x1*3 + y2*3*inputDimX];
    c01.g = input[x1*3 + y2*3*inputDimX + 1];
    c01.b = input[x1*3 + y2*3*inputDimX + 2];
    float4 c11;
    c11.r = input[x2*3 + y2*3*inputDimX];
    c11.g = input[x2*3 + y2*3*inputDimX + 1];
    c11.b = input[x2*3 + y2*3*inputDimX + 2];
    float4 c0 = lerp(c00, c10, x - x1);
    float4 c1 = lerp(c01, c11, x - x1);
    float4 colorOut = lerp(c0, c1, y - y1);
    output[index] = colorOut.r;
    output[index + 1] = colorOut.g;
    output[index + 2] = colorOut.b;
}

[numthreads(8,8,1)]
void makeTexture (uint3 id : SV_DispatchThreadID)
{
    // int index = id.x * 3 + (inputDimY-1-id.y) * 3 * inputDimX;
    // if ((id.x - (handX*inputDimX/256))*(id.x - (handX*inputDimX/256)) + ((inputDimY-1-id.y) - handY*inputDimY/256)*((inputDimY-1-id.y) - handY*inputDimY/256) < 10)
    // {
    //     outputTexture[id.xy] = float4(0, 1, 0, 1);
    // }
    // else
    // {
    //     outputTexture[id.xy] = float4(input[index]/255.0, input[index + 1]/255.0, input[index + 2]/255.0, 1);
    // }

    int index = id.x * 3 + (256-1-id.y) * 3 * 256;
    outputTexture[id.xy] = float4(output[index]/255.0, output[index + 1]/255.0, output[index + 2]/255.0, 1);
}
