#pragma kernel FindVelocity
#pragma kernel UpdateHeights
#pragma kernel UpdatePlane
#pragma kernel WaterColor
#pragma kernel AddWater

float c;
float xSize;
float zSize;
float dt;
float a;

float rainHeight;

bool clearWater;

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float4> fluxMap; // x = top, y = bottom, z = left, w = right
RWStructuredBuffer<float> depthMap;
RWStructuredBuffer<float> heightmap;
RWStructuredBuffer<float> heightmapRaw;
RWTexture2D<float4> colors;
int handPositionX;
int handPositionY;


[numthreads(8,8,1)]
void AddWater (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= xSize || id.y >= zSize)
        return;

    int index = id.x + id.y * xSize;
    if ((id.x-handPositionX)*(id.x-handPositionX) + (id.y-handPositionY)*(id.y-handPositionY) < 2500)
    {
        depthMap[index] += 10 * dt;
    }
}

[numthreads(8,8,1)]
void FindVelocity (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= xSize || id.y >= zSize)
        return;

    int vert = id.x + id.y * xSize;
    float4 flux = fluxMap[vert];
    float depth = depthMap[vert];
    float current = depth + heightmap[vert] - 0.1;

    float top = id.y < (zSize - 1) ? (depthMap[vert + xSize] + heightmap[vert + xSize] - 0.1) : current;
    float bottom = id.y > 0 ? (depthMap[vert - xSize] + heightmap[vert - xSize] - 0.1) : current;
    float left = id.x > 0 ? (depthMap[vert - 1] + heightmap[vert - 1] - 0.1) : current;
    float right = id.x < (xSize - 1) ? (depthMap[vert + 1] + heightmap[vert + 1] - 0.1) : current;

    float dtop = current - top;
    float dbottom = current - bottom;
    float dleft = current - left;
    float dright = current - right;

    flux.x = max(0, flux.x + dtop * a * dt * c);
    flux.y = max(0, flux.y + dbottom * a * dt * c);
    flux.z = max(0, flux.z + dleft * a * dt * c);
    flux.w = max(0, flux.w + dright * a * dt * c);

    float k = min(1, depth * a / ((flux.x + flux.y + flux.z + flux.w)*dt));

    flux.x *= k;
    flux.y *= k;
    flux.z *= k;
    flux.w *= k;

    if (id.x == 0) flux.z = 0;
    if (id.y == 0) flux.y = 0;
    if (id.x == xSize-1) flux.w = 0;
    if (id.y == zSize-1) flux.x = 0;

    fluxMap[vert] = max(0, flux);
}

[numthreads(8,8,1)]
void UpdateHeights (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= xSize || id.y >= zSize)
        return;

    int vert = id.x + id.y * xSize;
    float4 flux = fluxMap[vert];
    float outflux = flux.x + flux.y + flux.z + flux.w;

    float influxtop = id.y < (zSize-1) ? fluxMap[vert + xSize].y : 0;
    float influxbottom = id.y > 0 ? fluxMap[vert - xSize].x : 0;
    float influxleft = id.x > 0 ? fluxMap[vert - 1].w : 0;
    float influxright = id.x < (xSize-1) ? fluxMap[vert + 1].z: 0;
    
    float influx = influxtop + influxbottom + influxleft + influxright;

    float deltavolume = influx - outflux;

    depthMap[vert] += dt * deltavolume / a;
    vertices[vert].y = depthMap[vert] + heightmap[vert] - 0.1;

    if (clearWater)
    {
        depthMap[vert] = 0;
    }
}

[numthreads(8,8,1)]
void UpdatePlane (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= xSize || id.y >= zSize)
        return;

    int vert = id.x + id.y * xSize;
    vertices[vert].y = depthMap[vert] + heightmap[vert] - 0.1;
}

[numthreads(8,8,1)]
void WaterColor (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= xSize || id.y >= zSize)
        return;
    int vert = id.x + id.y * xSize;
    float depth = depthMap[vert];
    colors[id.xy] = float4(0, 0, 0.4, clamp(depth / 10, 0, 0.7));
}
