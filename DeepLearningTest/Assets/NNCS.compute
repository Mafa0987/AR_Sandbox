// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Bilinear

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> input;
RWStructuredBuffer<float> output;
RWStructuredBuffer<float> input2;
float ratioX;
float ratioY;
int inputDimX;
int inputDimY;

// Bilinear Interpolation
[numthreads(8,8,1)]
void Bilinear (uint3 id : SV_DispatchThreadID)
{
    int index = id.x * 3 + id.y * 3 * 240;
    float x = id.x * ratioX;
    float y = id.y * ratioY;
    int x1 = (int)floor(x);
    int y1 = (int)floor(y);
    int x2 = min(x1 + 1, inputDimX - 1);
    int y2 = min(y1 + 1, inputDimY - 1);
    float4 c00;
    c00.r = input2[x1*3 + y1*3*inputDimX];
    c00.g = input2[x1*3 + y1*3*inputDimX + 1];
    c00.b = input2[x1*3 + y1*3*inputDimX + 2];
    float4 c10;
    c10.r = input2[x2*3 + y1*3*inputDimX];
    c10.g = input2[x2*3 + y1*3*inputDimX + 1];
    c10.b = input2[x2*3 + y1*3*inputDimX + 2];
    float4 c01;
    c01.r = input2[x1*3 + y2*3*inputDimX];
    c01.g = input2[x1*3 + y2*3*inputDimX + 1];
    c01.b = input2[x1*3 + y2*3*inputDimX + 2];
    float4 c11;
    c11.r = input2[x2*3 + y2*3*inputDimX];
    c11.g = input2[x2*3 + y2*3*inputDimX + 1];
    c11.b = input2[x2*3 + y2*3*inputDimX + 2];
    float4 c0 = lerp(c00, c10, x - x1);
    float4 c1 = lerp(c01, c11, x - x1);
    float4 colorOut = lerp(c0, c1, y - y1);
    output[index] = colorOut.r;
    output[index + 1] = colorOut.g;
    output[index + 2] = colorOut.b;
}
